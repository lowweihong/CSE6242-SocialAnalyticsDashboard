<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sentiment Word Cloud Visualization</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
<style>
body {
  margin: 0;
  padding: 20px;
  font-family: Tektur, monospace;
  background-color: #2E3650;
  color: white;
}
#container {
  max-width: 900px;
  margin: 0 auto;
}
#visualization {
  margin-top: 20px;
  background-color: #1D253F;
  border-radius: 8px;
  overflow: hidden;
}
#container h1 {
  font-family: 'Tektur', monospace;
  font-weight: 600;
}
#loading, #error {
  text-align: center;
  padding: 20px;
  font-size: 18px;
  font-family: 'Tektur', monospace;
}
#error {
  color: #E9538A;
  display: none;
}
.tooltip {
  position: absolute;
  visibility: hidden;
  background-color: rgba(20, 20, 40, 0.9);
  color: white;
  padding: 10px;
  border-radius: 5px;
  pointer-events: none;
  font-family: 'Tektur', monospace;
  font-size: 14px;
  max-width: 200px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  z-index: 1000;
}
/* Time Selector Styles */
#timeframe-selector {
  margin: 20px 0;
  padding: 15px;
  background-color: #242B45;
  border-radius: 8px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
}
#timeframe-selector h3 {
  margin: 0 0 10px 0;
  color: #00F49E;
  font-family: 'Tektur', monospace;
}
.time-option {
  padding: 8px 15px;
  margin: 5px;
  background-color: #1D253F;
  border: 1px solid #3D4B6D;
  border-radius: 4px;
  color: white;
  cursor: pointer;
  font-family: 'Tektur', monospace;
  transition: all 0.2s ease;
}
.time-option:hover {
  background-color: #3D4B6D;
}
.time-option.active {
  background-color: #008FD6;
  border-color: #008FD6;
}
#date-range {
  display: flex;
  align-items: center;
  margin-left: 15px;
}
#date-range input {
  padding: 8px;
  background-color: #1D253F;
  border: 1px solid #3D4B6D;
  border-radius: 4px;
  color: white;
  font-family: 'Tektur', monospace;
  margin-right: 10px;
}
#date-range button {
  padding: 8px 15px;
  background-color: #00F49E;
  border: none;
  border-radius: 4px;
  color: #1D253F;
  font-family: 'Tektur', monospace;
  cursor: pointer;
  font-weight: bold;
}
#date-range button:hover {
  background-color: #00D895;
}
.timeframe-row {
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: flex-start;
}
.timeframe-label {
  margin-right: 10px;
  font-family: 'Tektur', monospace;
}
</style>
</head>
<body>
<div id="container">
<h1>Sentiment Analysis Word Cloud</h1>

<!-- Simplified Timeframe selector -->
<div id="timeframe-selector">
  <div class="timeframe-row">
    <h3>Timeframe:</h3>
    <button class="time-option active" data-period="all">All Time</button>
    <div id="date-range">
      <span class="timeframe-label">From</span>
      <input type="date" id="start-date" name="start-date">
      <span class="timeframe-label">To</span>
      <input type="date" id="end-date" name="end-date">
      <button id="apply-date-range">Apply</button>
    </div>
  </div>
</div>

<div id="loading">Loading data...</div>
<div id="error"></div>
<div id="visualization"></div>
</div>

<div class="tooltip"></div>

<script>
// D3.js Sentiment Word Cloud Visualization with Timeframe Filter

// Global variable to store the complete dataset
let fullDataset = [];
let currentTimeframe = 'all';
let startDate = null;
let endDate = null;

// CSV Processing Function
function processCsvData(csvData) {
  // Parse the CSV
  const parsedData = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true
  }).data;
  
  // Store the full dataset for filtering
  fullDataset = parsedData;
  
  // Process the data with the current timeframe
  return processDataByTimeframe(parsedData, currentTimeframe, startDate, endDate);
}

// Function to filter data by timeframe
function processDataByTimeframe(data, timeframe, customStartDate, customEndDate) {
  // Create a copy of the data to work with
  let filteredData = [...data];
  
  // Apply time filter based on selected option
  if (timeframe === 'custom' && customStartDate && customEndDate) {
    // Filter by custom date range
    filteredData = filteredData.filter(row => {
      if (!row.timestamp) return true; // Keep rows without timestamp
      const rowDate = new Date(row.timestamp);
      return !isNaN(rowDate) && rowDate >= customStartDate && rowDate <= customEndDate;
    });
    
    console.log(`Filtered to ${filteredData.length} rows for custom timeframe: ${customStartDate.toISOString()} to ${customEndDate.toISOString()}`);
  } else {
    console.log("Using all data (no timeframe filter)");
  }

  // Extract all topics and their sentiment scores
  let allTopics = [];
  filteredData.forEach(row => {
    if (row.topic && typeof row.topic === 'string') {
      const topics = row.topic.split(',').map(t => t.trim());
      topics.forEach(topic => {
        if (topic) {
          // Make sure we capture the correct sentiment label
          allTopics.push({
            text: topic,
            sentiment: row.sentiment_score || 0.5,
            sentimentLabel: row.sentiment_label || 'unknown',
            sentimentScore: row.sentiment_score,
            timestamp: row.timestamp
          });
        }
      });
    }
  });
  
  // Count occurrences of each topic
  const topicCounts = {};
  allTopics.forEach(item => {
    if (!topicCounts[item.text]) {
      topicCounts[item.text] = 0;
    }
    topicCounts[item.text]++;
  });
  
  // Calculate average sentiment for each topic
  const topicData = {};
  Object.keys(topicCounts).forEach(topic => {
    const items = allTopics.filter(item => item.text === topic);
    
    // Calculate average sentiment score
    let totalSentiment = 0;
    items.forEach(item => {
      totalSentiment += item.sentiment || 0.5;
    });
    const avgSentiment = totalSentiment / items.length;
    
    // Count occurrences of each sentiment label
    const labelCounts = {};
    items.forEach(item => {
      const label = item.sentimentLabel || 'unknown';
      labelCounts[label] = (labelCounts[label] || 0) + 1;
    });
    
    // Determine dominant sentiment label
    let dominantLabel = 'unknown';
    let maxCount = 0;
    Object.keys(labelCounts).forEach(label => {
      if (labelCounts[label] > maxCount) {
        maxCount = labelCounts[label];
        dominantLabel = label;
      }
    });
    
    topicData[topic] = {
      text: topic,
      value: topicCounts[topic],
      sentiment: avgSentiment,
      sentimentLabel: dominantLabel,
      mentioned: topicCounts[topic],
      labelCounts: labelCounts
    };
  });
  
  // Convert to array and sort by value (count)
  const processedData = Object.values(topicData)
    .sort((a, b) => b.value - a.value)
    .slice(0, 50); // Take top 50 topics
  
  return processedData;
}

// Create the visualization function
function createVisualization(data) {
  // Clear any existing SVG
  d3.select("#visualization").selectAll("*").remove();
  
  const width = 800;
  const height = 600;
  
  // Create SVG
  const svg = d3.select("#visualization")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", `0 0 ${width} ${height}`);
  
  // Fixed colors based on sentiment label (case-insensitive matching)
  const sentimentColors = {
    'positive': '#008FD6', // Blue for positive
    'negative': '#E9538A'  // Pink for negative
  };
  
  // Function to determine color based on sentiment label
  function getSentimentColor(label) {
    if (!label) return sentimentColors['positive']; // Default
    
    const normalizedLabel = String(label).toLowerCase();
    if (normalizedLabel.includes('negative')) {
      return sentimentColors['negative'];
    } else {
      return sentimentColors['positive']; // Default to positive for any other label
    }
  }
  
  // Background matching your screenshot
  svg.append('rect')
    .attr('width', width)
    .attr('height', height)
    .attr('fill', '#242B45'); // Slightly lighter navy for the visualization area
  
  // Title - centered as in your screenshot with Tektur font
  svg.append('text')
    .attr('x', width / 2)
    .attr('y', 40)
    .attr('text-anchor', 'middle')
    .attr('fill', '#00F49E') // Title color from the palette - bright green
    .style('font-size', '24px')
    .style('font-weight', 'bold')
    .style('font-family', "'Tektur', monospace")
    .text('Sentiment Word Cloud');
  
  // Legend - moved to bottom right as in your screenshot
  const legend = svg.append('g')
    .attr('transform', `translate(${width - 150}, ${height - 60})`);
    
  legend.append('rect')
    .attr('x', 0)
    .attr('y', 0)
    .attr('width', 16)
    .attr('height', 16)
    .attr('fill', sentimentColors['positive']);
    
  legend.append('text')
    .attr('x', 24)
    .attr('y', 12)
    .attr('fill', '#fff')
    .style('font-size', '14px')
    .style('font-family', "'Tektur', monospace")
    .text('Positive');
    
  legend.append('rect')
    .attr('x', 0)
    .attr('y', 24)
    .attr('width', 16)
    .attr('height', 16)
    .attr('fill', sentimentColors['negative']);
    
  legend.append('text')
    .attr('x', 24)
    .attr('y', 36)
    .attr('fill', '#fff')
    .style('font-size', '14px')
    .style('font-family', "'Tektur', monospace")
    .text('Negative');
    
  // Log sentiment distribution in visualization data
  const finalSentimentCount = {};
  data.forEach(d => {
    const label = d.sentimentLabel || 'unknown';
    finalSentimentCount[label] = (finalSentimentCount[label] || 0) + 1;
  });
  console.log("Visualization sentiment distribution:", finalSentimentCount);
  
  // Score range slider
  svg.append('text')
    .attr('x', 120)
    .attr('y', 30)
    .attr('fill', '#fff')
    .style('font-size', '14px')
    .style('font-family', "'Tektur', monospace")
    .text('Score Range');
  
  svg.append('line')
    .attr('x1', 60)
    .attr('y1', 50)
    .attr('x2', 180)
    .attr('y2', 50)
    .attr('stroke', '#fff')
    .attr('stroke-width', 2);
  
  svg.append('circle')
    .attr('cx', 60)
    .attr('cy', 50)
    .attr('r', 6)
    .attr('fill', '#fff');
  
  svg.append('circle')
    .attr('cx', 180)
    .attr('cy', 50)
    .attr('r', 6)
    .attr('fill', '#fff');
  
  svg.append('text')
    .attr('x', 60)
    .attr('y', 70)
    .attr('text-anchor', 'middle')
    .attr('fill', '#fff')
    .style('font-size', '12px')
    .style('font-family', "'Tektur', monospace")
    .text('0');
  
  svg.append('text')
    .attr('x', 180)
    .attr('y', 70)
    .attr('text-anchor', 'middle')
    .attr('fill', '#fff')
    .style('font-size', '12px')
    .style('font-family', "'Tektur', monospace")
    .text('1');
  
  // Get tooltip div
  const tooltip = d3.select(".tooltip");
  
  // Calculate node sizes based on value (frequency)
  const minValue = d3.min(data, d => d.value);
  const maxValue = d3.max(data, d => d.value);
  
  // Improved scaling for better differentiation
  const sizeScale = d3.scaleSqrt()
    .domain([minValue, maxValue])
    .range([30, 120]);
  
  // Create force simulation - adjusted to match your screenshot's more clustered layout
  const simulation = d3.forceSimulation(data)
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collide', d3.forceCollide().radius(d => sizeScale(d.value) / 1.8).strength(0.7))
    .force('charge', d3.forceManyBody().strength(-5)) // Reduced repulsion for tighter clustering
    .force('x', d3.forceX(width / 2).strength(0.1))
    .force('y', d3.forceY(height / 2).strength(0.1))
    .stop();
  
  // Run the simulation in advance - more iterations for better packing
  for (let i = 0; i < 500; i++) {
    simulation.tick();
  }
  
  // Create a group for all nodes
  const nodes = svg.selectAll('.node')
    .data(data)
    .enter()
    .append('g')
    .attr('class', 'node')
    .attr('transform', d => `translate(${d.x}, ${d.y})`);
  
  // Add circles for each node with color based on sentiment label
  nodes.append('circle')
    .attr('r', d => sizeScale(d.value) / 2)
    .attr('fill', d => getSentimentColor(d.sentimentLabel))
    .attr('fill-opacity', 0.7)
    .attr('stroke', d => getSentimentColor(d.sentimentLabel))
    .attr('stroke-width', 2)
    .attr('stroke-opacity', 0.9)
    .on('mouseover', function(event, d) {
      // Show tooltip
      tooltip
        .html(`<strong>${d.text}</strong><br>
              Sentiment Score: ${d.sentiment.toFixed(2)}<br>
              Label: ${d.sentimentLabel}<br>
              Mentioned: ${d.mentioned} times`)
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 20) + "px")
        .style("visibility", "visible");
      
      // Highlight this node
      d3.select(this)
        .attr('stroke-width', 3)
        .attr('stroke-opacity', 1)
        .attr('fill-opacity', 0.9);
    })
    .on('mouseout', function() {
      // Hide tooltip
      tooltip.style("visibility", "hidden");
      
      // Restore node appearance
      d3.select(this)
        .attr('stroke-width', 2)
        .attr('stroke-opacity', 0.9)
        .attr('fill-opacity', 0.7);
    });
  
  // Add text that dynamically fits within the circle
  nodes.append('text')
    .attr('text-anchor', 'middle')
    .attr('dy', '.3em')
    .attr('fill', '#fff')
    .style('font-family', "'Tektur', monospace")
    .style('font-weight', d => d.value > maxValue / 3 ? 'bold' : 'normal')
    .text(d => d.text)
    .each(function(d) {
      const circle_radius = sizeScale(d.value) / 2;
      const text = d3.select(this);
      const textLength = this.getComputedTextLength();
      const textHeight = 12; // Approximate height of text
      
      // Calculate the available width within the circle at text height
      // Using Pythagorean theorem to find width at the text's vertical position
      const availableWidth = 2 * Math.sqrt(Math.max(0, Math.pow(circle_radius, 2) - Math.pow(textHeight/2, 2)));
      
      // If text is wider than available width, scale it down
      if (textLength > availableWidth * 0.85) { // Using 85% of available width for padding
        const fontSize = Math.floor((availableWidth * 0.85 / textLength) * 16);
        text.style('font-size', `${Math.max(9, Math.min(fontSize, 24))}px`);
      } else {
        // Otherwise, scale based on node size but ensure it fits
        text.style('font-size', `${Math.max(10, Math.min(circle_radius / 2, 20))}px`);
      }
    });
}

// Log function to help with debugging
function logDataSample(data, label) {
  if (data && data.length > 0) {
    console.log(`${label} - Total items: ${data.length}`);
    console.log(`${label} - First 5 items:`, data.slice(0, 5));
    
    // Count sentiment labels
    const sentimentCounts = data.reduce((counts, item) => {
      const label = item.sentimentLabel || 'unknown';
      counts[label] = (counts[label] || 0) + 1;
      return counts;
    }, {});
    
    console.log(`${label} - Sentiment distribution:`, sentimentCounts);
  } else {
    console.log(`${label} - No data available`);
  }
}

// Function to update the visualization based on timeframe
function updateVisualization() {
  document.getElementById('loading').style.display = 'block';
  
  try {
    const processedData = processDataByTimeframe(fullDataset, currentTimeframe, startDate, endDate);
    
    // Log data to help with debugging
    logDataSample(processedData, `Processed CSV data (${currentTimeframe})`);
    
    // Only proceed with visualization if we have data
    if (processedData && processedData.length > 0) {
      createVisualization(processedData);
    } else {
      document.getElementById('error').textContent = 'No data available for the selected timeframe';
      document.getElementById('error').style.display = 'block';
    }
  } catch (error) {
    console.error("Error updating visualization:", error);
    document.getElementById('error').textContent = 'Failed to update visualization: ' + error.message;
    document.getElementById('error').style.display = 'block';
  }
  
  document.getElementById('loading').style.display = 'none';
}

// Set up event listeners for timeframe selector
function setupTimeframeSelectors() {
  // Set initial dates for the date pickers
  const today = new Date();
  const oneMonthAgo = new Date();
  oneMonthAgo.setMonth(today.getMonth() - 1);
  
  document.getElementById('start-date').valueAsDate = oneMonthAgo;
  document.getElementById('end-date').valueAsDate = today;
  
  // Add event listeners for the All Time button
  document.querySelector('.time-option[data-period="all"]').addEventListener('click', function() {
    // Set to all time
    currentTimeframe = 'all';
    startDate = null;
    endDate = null;
    
    // Highlight the All Time button
    this.classList.add('active');
    
    // Update visualization
    updateVisualization();
  });
  
  // Add event listener for custom date range
  document.getElementById('apply-date-range').addEventListener('click', function() {
    const startDateInput = document.getElementById('start-date').value;
    const endDateInput = document.getElementById('end-date').value;
    
    if (startDateInput && endDateInput) {
      // Remove active class from All Time button
      document.querySelector('.time-option').classList.remove('active');
      
      // Set current timeframe to custom
      currentTimeframe = 'custom';
      startDate = new Date(startDateInput);
      endDate = new Date(endDateInput);
      endDate.setHours(23, 59, 59); // Set to end of day
      
      // Update visualization
      updateVisualization();
    } else {
      alert('Please select both start and end dates');
    }
  });
}

// Main function to fetch CSV and create visualization
async function createSentimentWordCloud() {
  try {
    // Show loading indication
    document.getElementById('loading').style.display = 'block';
    document.getElementById('error').style.display = 'none';
    
    // Fetch CSV data
    try {
      const response = await fetch('out_40k.csv');
      if (response.ok) {
        const csvData = await response.text();
        const processedData = processCsvData(csvData);
        
        // Log data to help with debugging
        logDataSample(processedData, "Processed CSV data");
        
        // Only proceed with visualization if we have data
        if (processedData && processedData.length > 0) {
          createVisualization(processedData);
        } else {
          throw new Error("No valid data found in CSV");
        }
      } else {
        throw new Error("Failed to fetch CSV file: " + response.status);
      }
    } catch (error) {
      console.error("Error loading CSV data:", error);
      document.getElementById('error').textContent = 'Failed to load CSV data: ' + error.message;
      document.getElementById('error').style.display = 'block';
    }
    
    // Hide loading
    document.getElementById('loading').style.display = 'none';
  } catch (error) {
    console.error('Error creating visualization:', error);
    // Show error message
    document.getElementById('loading').style.display = 'none';
    document.getElementById('error').textContent = 'Failed to create visualization. Please try again.';
    document.getElementById('error').style.display = 'block';
  }
}

// Call the main function when the page loads
document.addEventListener('DOMContentLoaded', function() {
  setupTimeframeSelectors();
  createSentimentWordCloud();
});
</script>
</body>
</html>