<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Social Analytics Dashboard</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
    }
    .dashboard {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }
    .chart {
      background: #fff;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
      min-height: 550px; /* Increased minimum height */
      position: relative;
    }
    .chart h3.chart-title {
      margin: 0 0 20px 0;
      text-align: center;
      color: #333;
      font-size: 16px;
      z-index: 2;
      position: relative;
    }
    .chart svg {
      position: absolute;
      top: 60px;
      left: 20px;
      right: 20px;
      bottom: 20px;
      width: calc(100% - 40px);
      height: calc(100% - 80px);
    }
    .chart-full {
      grid-column: 1 / -1;
      min-height: 400px;
    }
    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 2;
    }
    .area {
      opacity: 0.7;
    }
    .bubble {
      fill-opacity: 0.7;
      stroke: #fff;
    }
    .axis-label {
      font-size: 12px;
      fill: #666;
    }
    .tooltip {
      position: absolute;
      padding: 8px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      z-index: 1000;
    }
    .filters {
      grid-column: 1 / -1;
      background: #fff;
      padding: 20px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
    }
    .filter-group {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .filter-group label {
      font-weight: bold;
      color: #333;
    }
    select, input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    select:focus, input:focus {
      outline: none;
      border-color: #4a90e2;
      box-shadow: 0 0 0 2px rgba(74,144,226,0.2);
    }
    @media (max-width: 1200px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
      
      .chart {
        min-height: 400px;
      }
    }
    @media (max-width: 768px) {
      .filters {
        flex-direction: column;
        align-items: stretch;
      }
      
      .filter-group {
        flex-direction: column;
        align-items: stretch;
      }
      
      .chart {
        min-height: 350px;
      }
    }
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      z-index: 1000;
    }
    .error-message {
      color: #e74c3c;
      padding: 10px;
      margin: 10px 0;
      background: #fdf0ed;
      border: 1px solid #e74c3c;
      border-radius: 4px;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
    }
    .modal {
      background: rgba(0, 0, 0, 0.5);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
  </style>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const startDateInput = document.getElementById('startDate');
      const endDateInput = document.getElementById('endDate');
      const sentimentFilterSelect = document.getElementById('sentimentFilter');

      // Set date filter range
      const minDate = "2007-04-19T07:14:38+00:00";
      const maxDate = "2019-11-23T15:44:33+00:00";

      startDateInput.min = minDate.split('T')[0];
      startDateInput.max = maxDate.split('T')[0];
      endDateInput.min = minDate.split('T')[0];
      endDateInput.max = maxDate.split('T')[0];

      // Set default values
      startDateInput.value = minDate.split('T')[0];
      endDateInput.value = maxDate.split('T')[0];

      // Add filter event listeners
      startDateInput.addEventListener('change', updateCharts);
      endDateInput.addEventListener('change', updateCharts);
      sentimentFilterSelect.addEventListener('change', updateCharts);

      // Function to update charts
      function updateCharts() {
        const startDate = new Date(startDateInput.value);
        const endDate = new Date(endDateInput.value);
        const selectedSentiment = sentimentFilterSelect.value;

        if (startDate > endDate) {
          alert("Start date cannot be later than end date!");
          return;
        }

        // Filter data - date filtering
        let filteredData = testData.sentiment.filter(d => {
          return d.timestamp >= startDate && d.timestamp <= endDate;
        });

        // Sentiment category filtering
        if (selectedSentiment !== 'all') {
          filteredData = filteredData.filter(d => {
            return d.sentiment_label === selectedSentiment;
          });
        }

        if (filteredData.length === 0) {
          alert("No data matches the criteria!");
          return;
        }

        // Update charts
        createSentimentLineChart(filteredData);
        createStackedAreaChart(filteredData);
        createHeatmapChart(filteredData);
      }
    });
  </script>
</head>
<body>
  <h1>Bitcoin Social Sentiment Analysis Dashboard</h1>
  
  <div id="loadingIndicator" class="loading" style="display: none;">
    Loading data, please wait...
  </div>
  
  <div id="errorContainer" class="error-message" style="display: none;"></div>
  
  <div class="dashboard">
    <div class="filters">
      <div class="filter-group">
        <label>Time Range:</label>
        <input type="date" id="startDate">
        <input type="date" id="endDate">
      </div>
      <div class="filter-group">
        <label>Sentiment Category:</label>
        <select id="sentimentFilter">
          <option value="all">All</option>
          <option value="positive">Positive</option>
          <option value="neutral">Neutral</option>
          <option value="negative">Negative</option>
        </select>
      </div>
    </div>
    
    <div id="sentimentLineChart" class="chart chart-full">
      <h3 class="chart-title">Bitcoin Social Sentiment Trend</h3>
    </div>
    <div id="stackedAreaChart" class="chart chart-full">
      <h3 class="chart-title">Sentiment Distribution Trend</h3>
    </div>
    <div id="topicBubbleChart" class="chart">
      <h3 class="chart-title">Topic Distribution and Keywords</h3>
    </div>
    <div id="heatmapChart" class="chart">
      <h3 class="chart-title">Weekly Sentiment Activity Distribution</h3>
    </div>
  </div>

  <script>
    // Show loading indicator
    function showLoading(show = true) {
      document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
    }

    // Show error message
    function showError(message) {
      const errorContainer = document.getElementById('errorContainer');
      if (message) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
      } else {
        errorContainer.style.display = 'none';
      }
    }

    // Create tooltip
    const tooltip = d3.select("body")
      .append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    // Add test data
    const testData = {
      sentiment: Array.from({ length: 100 }, (_, i) => ({
        timestamp: new Date(2007, 3, 19 + Math.floor(i * (4628 / 100))),
        sentiment: 0.3 + Math.random() * 0.4,
        sentiment_label: Math.random() > 0.5 ? "positive" : (Math.random() > 0.5 ? "neutral" : "negative"),
        topic: ["Bitcoin Price", "Market Trends", "Regulatory Policies", "Technology Development"][Math.floor(Math.random() * 4)],
        text: "Test data " + (i + 1)
      }))
    };

    // Modify data loading function
    async function loadData() {
      showLoading(true);
      showError(null);
      
      try {
        console.log('Starting data loading...');
        
        let sentimentData, topicData;
        
        try {
          [sentimentData, topicData] = await Promise.all([
            d3.csv("combined_df_new_test.csv"),
            d3.csv("topic_detail_new_test.csv")
          ]);
        } catch (error) {
          console.warn('Using test data set:', error);
          sentimentData = testData.sentiment;
          topicData = [];
        }

        console.log('Original sentiment data:', sentimentData.length, 'records');
        if (topicData) console.log('Original topic data:', topicData.length, 'records');
        console.log('Data sample:', sentimentData[0]);

        // Data preprocessing
        const validData = sentimentData
          .filter(d => {
            const isValid = d.timestamp && d.sentiment_score;
            if (!isValid) {
              console.log('Invalid data:', d);
            }
            return isValid;
          })
          .map(d => {
            const parsed = {
              timestamp: new Date(d.timestamp),
              sentiment: parseFloat(d.sentiment_score),
              sentiment_label: d.sentiment_label,
              topic: d.topic,
              text: d.text
            };
            if (isNaN(parsed.timestamp.getTime()) || isNaN(parsed.sentiment)) {
              console.log('Failed parsing data:', d);
            }
            return parsed;
          })
          .filter(d => !isNaN(d.timestamp) && !isNaN(d.sentiment))
          .sort((a, b) => a.timestamp - b.timestamp);

        console.log('Valid data:', validData.length, 'records');
        console.log('Valid data sample:', validData[0]);

        if (validData.length === 0) {
          throw new Error('No valid data points');
        }

        // Process topic data
        const topicSummary = d3.rollup(validData,
          v => ({
            count: v.length,
            avgSentiment: d3.mean(v, d => d.sentiment)
          }),
          d => d.topic
        );

        console.log('Topic summary:', Array.from(topicSummary.entries()));

        // Check container elements
        const containers = ['sentimentLineChart', 'stackedAreaChart', 'topicBubbleChart', 'heatmapChart'];
        containers.forEach(id => {
          const container = document.getElementById(id);
          if (!container) {
            console.error(`Container element not found: ${id}`);
          } else {
            console.log(`Container ${id} dimensions:`, container.clientWidth, 'x', container.clientHeight);
          }
        });

        // Create all charts
        try {
          console.log('Starting line chart creation...');
          createSentimentLineChart(validData);
          
          console.log('Starting stacked area chart creation...');
          createStackedAreaChart(validData);
          
          console.log('Starting topic bubble chart creation...');
          createTopicBubbleChart(topicSummary);
          
          console.log('Starting heatmap creation...');
          createHeatmapChart(validData);
          
          console.log('All charts created');
        } catch (error) {
          console.error('Chart creation error:', error);
          throw error;
        }

        // Set filter initial dates to data set time range
        const startDate = new Date("2007-04-19T07:14:38Z");
        const endDate = new Date("2019-11-23T15:44:33Z");
        
        document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
        document.getElementById('endDate').value = endDate.toISOString().split('T')[0];

        // If data loaded successfully, we'll use the actual time range of the data
        if (validData.length > 0) {
          const timeExtent = d3.extent(validData, d => d.timestamp);
          // Ensure time range doesn't exceed the actual range of the dataset
          document.getElementById('startDate').value = timeExtent[0].toISOString().split('T')[0];
          document.getElementById('endDate').value = timeExtent[1].toISOString().split('T')[0];
        }

      } catch (error) {
        console.error('Error details:', error);
        showError('Data loading error: ' + error.message);
      } finally {
        showLoading(false);
      }
    }

    // Start application
    document.addEventListener('DOMContentLoaded', loadData);

    // Add data validation function
    function validateData(data) {
      if (!Array.isArray(data)) {
        console.error('Data is not an array');
        return false;
      }
      
      if (data.length === 0) {
        console.error('Data array is empty');
        return false;
      }
      
      const requiredFields = ['timestamp', 'sentiment', 'sentiment_label', 'topic', 'text'];
      const sample = data[0];
      
      const missingFields = requiredFields.filter(field => !(field in sample));
      if (missingFields.length > 0) {
        console.error('Data missing required fields:', missingFields);
        return false;
      }
      
      return true;
    }

    function createSentimentLineChart(data) {
      try {
        if (!validateData(data)) {
          throw new Error('Data validation failed');
        }
        const container = document.getElementById("sentimentLineChart");
        if (!container) {
          throw new Error('Line chart container element not found');
        }

        // Clear existing content
        d3.select("#sentimentLineChart svg").remove();
        
        const width = container.clientWidth - 80;
        const height = container.clientHeight - 100;
        const margin = {top: 20, right: 40, bottom: 50, left: 50};
        
        const svg = d3.select("#sentimentLineChart")
          .append("svg")
          .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);
        
        const x = d3.scaleTime()
                    .domain(d3.extent(data, d => d.timestamp))
                    .range([0, width]);
        
        const y = d3.scaleLinear()
                    .domain([0, 1])
                    .range([height, 0]);
        
        const line = d3.line()
                       .x(d => x(d.timestamp))
                       .y(d => y(d.sentiment))
                       .curve(d3.curveMonotoneX);
        
        // Add X axis
        svg.append("g")
           .attr("transform", `translate(0,${height})`)
           .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%m/%Y")))
           .selectAll("text")
           .style("text-anchor", "end")
           .attr("dx", "-.8em")
           .attr("dy", ".15em")
           .attr("transform", "rotate(-45)");
        
        // Add Y axis
        svg.append("g")
           .call(d3.axisLeft(y));
        
        // Add X axis label
        svg.append("text")
           .attr("class", "axis-label")
           .attr("x", width / 2)
           .attr("y", height + margin.bottom - 5)
           .style("text-anchor", "middle")
           .text("Time");
        
        // Add Y axis label
        svg.append("text")
           .attr("class", "axis-label")
           .attr("transform", "rotate(-90)")
           .attr("x", -height / 2)
           .attr("y", -margin.left + 15)
           .style("text-anchor", "middle")
           .text("Sentiment Score");
        
        // Add line
        const path = svg.append("path")
           .datum(data)
           .attr("class", "line")
           .attr("d", line);

        // Add interactive elements
        const focus = svg.append("g")
           .attr("class", "focus")
           .style("display", "none");
        
        // Add a circle to track the nearest data point
        focus.append("circle")
           .attr("r", 5)
           .style("fill", "steelblue")
           .style("stroke", "white");
        
        // Add a vertical reference line
        focus.append("line")
           .attr("class", "x-hover-line")
           .attr("y1", 0)
           .attr("y2", height)
           .style("stroke", "#ddd")
           .style("stroke-width", "1px")
           .style("stroke-dasharray", "3,3");
        
        // Add interaction area
        svg.append("rect")
           .attr("class", "overlay")
           .attr("width", width)
           .attr("height", height)
           .style("fill", "none")
           .style("pointer-events", "all")
           .on("mouseover", () => focus.style("display", null))
           .on("mouseout", () => {
             focus.style("display", "none");
             tooltip.transition().duration(300).style("opacity", 0);
           })
           .on("mousemove", mousemove);
        
        // Mouse move handler function
        function mousemove(event) {
          const bisect = d3.bisector(d => d.timestamp).left;
          const x0 = x.invert(d3.pointer(event)[0]);
          const i = bisect(data, x0, 1);
          const d0 = data[i - 1];
          const d1 = data[i];
          
          // Find the data point closest to the mouse position
          const d = x0 - d0.timestamp > d1.timestamp - x0 ? d1 : d0;
          
          // Update circle position
          focus.attr("transform", `translate(${x(d.timestamp)},${y(d.sentiment)})`);
          
          // Update vertical line position
          focus.select(".x-hover-line").attr("transform", `translate(0,${-y(d.sentiment)})`);
          
          // Show tooltip
          const dateFormat = d3.timeFormat("%Y-%m-%d");
          tooltip.transition()
             .duration(200)
             .style("opacity", .9);
          
          tooltip.html(`
            <strong>Date: ${dateFormat(d.timestamp)}</strong><br/>
            Sentiment Score: ${d.sentiment.toFixed(3)}<br/>
            Sentiment Category: ${d.sentiment_label}<br/>
            ${d.text ? `<small>${d.text}</small>` : ''}
          `)
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 30) + "px");
        }
      } catch (error) {
        console.error('Line chart creation error:', error);
        throw error;
      }
    }

    function createStackedAreaChart(data) {
      try {
        const container = document.getElementById("stackedAreaChart");
        if (!container) {
          throw new Error('Stacked area chart container element not found');
        }

        // Clear existing content
        d3.select("#stackedAreaChart svg").remove();
        
        const width = container.clientWidth - 80;
        const height = container.clientHeight - 100;
        const margin = {top: 20, right: 40, bottom: 50, left: 50};
        
        const svg = d3.select("#stackedAreaChart")
          .append("svg")
          .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Use weeks for aggregation instead of days to avoid sparse data
        const parseTime = d3.timeWeek;
        
        // Sort data to ensure correct time order
        data.sort((a, b) => a.timestamp - b.timestamp);
        
        // Create a mapping for sentiment category counts
        const timeMap = new Map();
        
        // Calculate the week for each data point and count by sentiment category
        data.forEach(d => {
          const weekKey = parseTime(d.timestamp);
          if (!timeMap.has(weekKey)) {
            timeMap.set(weekKey, {
              date: weekKey,
              positive: 0,
              neutral: 0,
              negative: 0
            });
          }
          
          const entry = timeMap.get(weekKey);
          if (d.sentiment_label === "positive") {
            entry.positive += 1;
          } else if (d.sentiment_label === "neutral") {
            entry.neutral += 1;
          } else if (d.sentiment_label === "negative") {
            entry.negative += 1;
          }
        });
        
        // Convert to array and ensure sorted by date
        const stackData = Array.from(timeMap.values())
          .sort((a, b) => a.date - b.date);
        
        // Ensure data is available
        if (stackData.length < 2) {
          svg.append("text")
            .attr("x", width / 2)
            .attr("y", height / 2)
            .attr("text-anchor", "middle")
            .text("Insufficient data to generate stacked area chart");
          return;
        }

        // Use d3.stack to create stacked data structure
        const stack = d3.stack()
          .keys(["positive", "neutral", "negative"]);

        const series = stack(stackData);

        // Set scales
        const x = d3.scaleTime()
          .domain(d3.extent(stackData, d => d.date))
          .range([0, width]);

        const y = d3.scaleLinear()
          .domain([0, d3.max(series, d => d3.max(d, d => d[1]))])
          .range([height, 0]);

        // Define sentiment category colors
        const color = d3.scaleOrdinal()
          .domain(["positive", "neutral", "negative"])
          .range(["#2ecc71", "#95a5a6", "#e74c3c"]);

        // Define area generator
        const area = d3.area()
          .x(d => x(d.data.date))
          .y0(d => y(d[0]))
          .y1(d => y(d[1]))
          .curve(d3.curveMonotoneX);

        // Add areas
        svg.selectAll(".area")
           .data(series)
           .join("path")
           .attr("class", "area")
           .style("fill", d => color(d.key))
           .attr("d", area)
           .on("mouseover", function(event, d) {
             d3.select(this)
               .style("opacity", 1)
               .style("stroke", "#000")
               .style("stroke-width", 1);
               
             tooltip.transition()
               .duration(200)
               .style("opacity", .9);
             
             const categoryLabel = d.key === "positive" ? "Positive" :
                                  d.key === "neutral" ? "Neutral" : "Negative";
             
             tooltip.html(`<strong>Category: ${categoryLabel}</strong>`)
               .style("left", (event.pageX + 10) + "px")
               .style("top", (event.pageY - 28) + "px");
           })
           .on("mouseout", function() {
             d3.select(this)
               .style("opacity", 0.7)
               .style("stroke", "none");
               
             tooltip.transition()
               .duration(500)
               .style("opacity", 0);
           });

        // Add X axis
        svg.append("g")
           .attr("transform", `translate(0,${height})`)
           .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%Y-%m")))
           .selectAll("text")
           .style("text-anchor", "end")
           .attr("dx", "-.8em")
           .attr("dy", ".15em")
           .attr("transform", "rotate(-45)");

        // Add Y axis
        svg.append("g")
           .call(d3.axisLeft(y));
           
        // Add X axis label
        svg.append("text")
           .attr("class", "axis-label")
           .attr("x", width / 2)
           .attr("y", height + margin.bottom - 5)
           .style("text-anchor", "middle")
           .text("Time");
           
        // Add Y axis label
        svg.append("text")
           .attr("class", "axis-label")
           .attr("transform", "rotate(-90)")
           .attr("x", -height / 2)
           .attr("y", -margin.left + 15)
           .style("text-anchor", "middle")
           .text("Count");

        // Add legend
        const legend = svg.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${width - 100}, 0)`);

        const legendData = [
          {key: "positive", label: "Positive"},
          {key: "neutral", label: "Neutral"},
          {key: "negative", label: "Negative"}
        ];

        legendData.forEach((d, i) => {
          const g = legend.append("g")
            .attr("transform", `translate(0, ${i * 20})`);

          g.append("rect")
            .attr("width", 15)
            .attr("height", 15)
            .style("fill", color(d.key));

          g.append("text")
            .attr("x", 20)
            .attr("y", 12)
            .text(d.label);
        });
        
        // Add interaction area to show details
        svg.append("rect")
          .attr("width", width)
          .attr("height", height)
          .style("fill", "none")
          .style("pointer-events", "all")
          .on("mousemove", mousemove);
          
        function mousemove(event) {
          const [mouseX] = d3.pointer(event);
          const date = x.invert(mouseX);
          
          // Find the nearest data point
          const bisect = d3.bisector(d => d.date).left;
          const index = bisect(stackData, date, 1);
          const d0 = stackData[Math.max(0, index - 1)];
          const d1 = stackData[Math.min(stackData.length - 1, index)];
          const d = date - d0.date > d1.date - date ? d1 : d0;
          
          if (d) {
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(`
              <strong>Date: ${d3.timeFormat("%Y-%m-%d")(d.date)}</strong><br/>
              Positive: ${d.positive}<br/>
              Neutral: ${d.neutral}<br/>
              Negative: ${d.negative}
            `)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          }
        }
      } catch (error) {
        console.error('Stacked area chart creation error:', error);
        throw error;
      }
    }

    function createTopicBubbleChart(topicData) {
      // Clear existing content
      d3.select("#topicBubbleChart").selectAll("*").remove();
      
      const container = document.getElementById("topicBubbleChart");
      const width = container.clientWidth - 80;
      const height = container.clientHeight - 100; // Increased height
      const margin = {top: 50, right: 70, bottom: 50, left: 50}; // Increased margins

      const svg = d3.select("#topicBubbleChart")
                    .append("svg")
                    .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                    .attr("preserveAspectRatio", "xMidYMid meet")
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

      svg.append("text")
         .attr("class", "chart-title")
         .attr("x", width / 2)
         .attr("y", -margin.top / 2)
         .text("Topic Distribution and Keywords");

      const data = Array.from(topicData, ([key, value]) => ({
        topic: key,
        ...value
      }));

      // Modify bubble packing algorithm parameters
      const pack = d3.pack()
        .size([width - margin.left - margin.right, height - margin.top - margin.bottom])
        .padding(8); // Increased bubble spacing

      const root = d3.hierarchy({children: data})
        .sum(d => d.count);

      const nodes = pack(root).leaves();

      // Use a richer color scheme
      const color = d3.scaleSequential()
        .domain([0, 1])
        .interpolator(d3.interpolateViridis);

      // Create bubble groups
      const bubbleGroups = svg.selectAll(".bubble-group")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "bubble-group")
        .attr("transform", d => `translate(${d.x},${d.y})`);

      // Add bubbles
      bubbleGroups.append("circle")
        .attr("class", "bubble")
        .attr("r", d => d.r)
        .style("fill", d => color(d.data.avgSentiment))
        .style("fill-opacity", 0.7)
        .style("stroke", "#fff")
        .style("stroke-width", 2)
        .on("mouseover", function(event, d) {
          d3.select(this)
            .style("stroke", "#000")
            .style("stroke-width", 3)
            .style("fill-opacity", 0.9);
          
          tooltip.transition()
            .duration(200)
            .style("opacity", .9);
          
          tooltip.html(`
            <strong>Topic: ${d.data.topic}</strong><br/>
            <hr style="margin: 5px 0"/>
            Count: ${d.data.count} tweets<br/>
            Avg Sentiment: ${d.data.avgSentiment.toFixed(3)}<br/>
            <hr style="margin: 5px 0"/>
            <small>Click to view details</small>
          `)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          d3.select(this)
            .style("stroke", "#fff")
            .style("stroke-width", 2)
            .style("fill-opacity", 0.7);
          
          tooltip.transition()
            .duration(500)
            .style("opacity", 0);
        })
        .on("click", function(event, d) {
          // Show topic details
          showTopicDetail(d.data);
        });

      // Add text labels to larger bubbles
      bubbleGroups.filter(d => d.r > 30)
        .append("text")
        .attr("dy", ".3em")
        .style("text-anchor", "middle")
        .style("font-size", d => Math.min(d.r / 3, 12) + "px")
        .style("fill", "#fff")
        .text(d => d.data.topic);

      // Add legend
      const legendWidth = 120;
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width - legendWidth - 20}, 0)`); // Shift left a bit

      const legendGradient = legend.append("defs")
        .append("linearGradient")
        .attr("id", "sentiment-gradient")
        .attr("x1", "0%")
        .attr("y1", "100%")
        .attr("x2", "0%")
        .attr("y2", "0%");

      legendGradient.selectAll("stop")
        .data(d3.range(0, 1.1, 0.1))
        .enter()
        .append("stop")
        .attr("offset", d => d * 100 + "%")
        .attr("stop-color", d => color(d));

      legend.append("rect")
        .attr("width", 20)
        .attr("height", 100)
        .style("fill", "url(#sentiment-gradient)");

      legend.append("text")
        .attr("x", 25)
        .attr("y", 0)
        .attr("dy", "1em")
        .text("Sentiment Score");

      legend.append("text")
        .attr("x", 25)
        .attr("y", 100)
        .text("0.0");

      legend.append("text")
        .attr("x", 25)
        .attr("y", 0)
        .text("1.0");
    }

    function showTopicDetail(topicData) {
      // Create modal to show topic details
      const modal = d3.select("body")
        .append("div")
        .attr("class", "modal")
        .style("position", "fixed")
        .style("left", "50%")
        .style("top", "50%")
        .style("transform", "translate(-50%, -50%)")
        .style("background", "white")
        .style("padding", "20px")
        .style("border-radius", "8px")
        .style("box-shadow", "0 4px 6px rgba(0,0,0,0.1)")
        .style("z-index", "1000")
        .style("max-width", "600px")
        .style("width", "90%");

      modal.html(`
        <h3 style="margin-top:0">Topic: ${topicData.topic}</h3>
        <hr/>
        <p><strong>Tweet Count:</strong> ${topicData.count}</p>
        <p><strong>Avg Sentiment Score:</strong> ${topicData.avgSentiment.toFixed(3)}</p>
        <p><strong>Sentiment Tendency:</strong> ${getTopicSentimentLabel(topicData.avgSentiment)}</p>
        <hr/>
        <button onclick="this.parentElement.remove()" style="
          padding: 8px 16px;
          background: #4a90e2;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        ">Close</button>
      `);
    }

    function getTopicSentimentLabel(sentiment) {
      if (sentiment >= 0.6) return "Strongly Positive";
      if (sentiment >= 0.5) return "Positive";
      if (sentiment > 0.4) return "Neutral";
      if (sentiment >= 0.3) return "Negative";
      return "Strongly Negative";
    }

    function createHeatmapChart(data) {
      // Clear existing content
      d3.select("#heatmapChart").selectAll("*").remove();
      
      const container = document.getElementById("heatmapChart");
      const width = container.clientWidth - 100; // Reduce width to leave space for margins
      const height = container.clientHeight - 100; // Increased height
      const margin = {top: 50, right: 80, bottom: 60, left: 70}; // Increased all margins

      const svg = d3.select("#heatmapChart")
                    .append("svg")
                    .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                    .attr("preserveAspectRatio", "xMidYMid meet")
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

      svg.append("text")
         .attr("class", "chart-title")
         .attr("x", width / 2)
         .attr("y", -margin.top / 2)
         .text("Weekly Sentiment Activity Distribution");

      // Aggregate data by hour and day of the week
      const heatmapData = d3.rollup(data,
        v => ({
          count: v.length,
          avgSentiment: d3.mean(v, d => d.sentiment),
          tweets: v // Save original tweet data
        }),
        d => d.timestamp.getHours(),
        d => d.timestamp.getDay()
      );

      const hours = Array.from({length: 24}, (_, i) => i);
      const days = Array.from({length: 7}, (_, i) => i);

      const gridData = [];
      hours.forEach(hour => {
        days.forEach(day => {
          const value = heatmapData.get(hour)?.get(day) || {count: 0, avgSentiment: 0, tweets: []};
          gridData.push({
            hour,
            day,
            ...value
          });
        });
      });

      const x = d3.scaleBand()
        .domain(hours)
        .range([0, width])
        .padding(0.1);

      const y = d3.scaleBand()
        .domain(days)
        .range([0, height])
        .padding(0.1);

      // Use a better color scheme
      const color = d3.scaleSequential()
        .domain([0, d3.max(gridData, d => d.count)])
        .interpolator(d3.interpolateYlOrRd);

      const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

      // Add cells
      svg.selectAll(".cell")
         .data(gridData)
         .enter()
         .append("rect")
         .attr("class", "cell")
         .attr("x", d => x(d.hour))
         .attr("y", d => y(d.day))
         .attr("width", x.bandwidth())
         .attr("height", y.bandwidth())
         .style("fill", d => d.count > 0 ? color(d.count) : "#f8f9fa")
         .style("stroke", "#fff")
         .style("stroke-width", 1)
         .on("mouseover", function(event, d) {
           d3.select(this)
             .style("stroke", "#000")
             .style("stroke-width", 2);
           
           const sentimentLabel = d.avgSentiment ? getTopicSentimentLabel(d.avgSentiment) : "No Data";
           const formattedHour = d.hour.toString().padStart(2, '0');
           
           tooltip.transition()
             .duration(200)
             .style("opacity", .9);
           
           tooltip.html(`
             <strong>${dayNames[d.day]} ${formattedHour}:00</strong><br/>
             <hr style="margin: 5px 0"/>
             Tweet Count: ${d.count}<br/>
             Avg Sentiment: ${d.avgSentiment ? d.avgSentiment.toFixed(3) : "N/A"}<br/>
             Sentiment Tendency: ${sentimentLabel}<br/>
             ${d.count > 0 ? "<small>Click to view details</small>" : ""}
           `)
             .style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 28) + "px");
         })
         .on("mouseout", function() {
           d3.select(this)
             .style("stroke", "#fff")
             .style("stroke-width", 1);
           
           tooltip.transition()
             .duration(500)
             .style("opacity", 0);
         })
         .on("click", function(event, d) {
           if (d.count > 0) {
             showTimeSlotDetail(d);
           }
         });

      // Add axes
      svg.append("g")
         .attr("transform", `translate(0,${height})`)
         .call(d3.axisBottom(x).tickFormat(d => `${d.toString().padStart(2, '0')}:00`))
         .selectAll("text")
         .style("text-anchor", "end")
         .attr("dx", "-.8em")
         .attr("dy", ".15em")
         .attr("transform", "rotate(-45)");

      svg.append("g")
         .call(d3.axisLeft(y).tickFormat(d => dayNames[d]));

      // Add legend
      const legendWidth = 20;
      const legendHeight = height;
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width + 10}, 0)`); // Shift left 10px

      const legendScale = d3.scaleLinear()
        .domain([0, d3.max(gridData, d => d.count)])
        .range([legendHeight, 0]);

      const legendAxis = d3.axisRight(legendScale)
        .ticks(5);

      const legendGradient = legend.append("defs")
        .append("linearGradient")
        .attr("id", "heatmap-gradient")
        .attr("x1", "0%")
        .attr("y1", "100%")
        .attr("x2", "0%")
        .attr("y2", "0%")
        .selectAll("stop")
        .data(d3.range(0, 1.1, 0.1))
        .enter()
        .append("stop")
        .attr("offset", d => d * 100 + "%")
        .attr("stop-color", d => color(d * d3.max(gridData, d => d.count)));

      legend.append("rect")
        .attr("width", legendWidth)
        .attr("height", legendHeight)
        .style("fill", "url(#heatmap-gradient)");

      legend.append("g")
        .attr("transform", `translate(${legendWidth}, 0)`)
        .call(legendAxis)
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 35)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Tweet Count");
    }

    function showTimeSlotDetail(data) {
      const modal = d3.select("body")
        .append("div")
        .attr("class", "modal")
        .style("position", "fixed")
        .style("left", "50%")
        .style("top", "50%")
        .style("transform", "translate(-50%, -50%)")
        .style("background", "white")
        .style("padding", "20px")
        .style("border-radius", "8px")
        .style("box-shadow", "0 4px 6px rgba(0,0,0,0.1)")
        .style("z-index", "1000")
        .style("max-width", "600px")
        .style("width", "90%")
        .style("max-height", "80vh")
        .style("overflow-y", "auto");

      const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const formattedHour = data.hour.toString().padStart(2, '0');

      modal.html(`
        <h3 style="margin-top:0">${dayNames[data.day]} ${formattedHour}:00 Time Slot Analysis</h3>
        <hr/>
        <p><strong>Total Tweets:</strong> ${data.count}</p>
        <p><strong>Avg Sentiment Score:</strong> ${data.avgSentiment.toFixed(3)}</p>
        <p><strong>Sentiment Tendency:</strong> ${getTopicSentimentLabel(data.avgSentiment)}</p>
        <hr/>
        <h4>Tweet Examples:</h4>
        <div style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding: 10px; margin: 10px 0;">
          ${data.tweets.slice(0, 5).map(tweet => `
            <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
              <p style="margin: 5px 0;">${tweet.text}</p>
              <small style="color: #666;">Sentiment Score: ${tweet.sentiment.toFixed(3)}</small>
            </div>
          `).join('')}
        </div>
        <button onclick="this.parentElement.remove()" style="
          padding: 8px 16px;
          background: #4a90e2;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          margin-top: 10px;
        ">Close</button>
      `);
    }

    // Add responsive handling on window resize
    window.addEventListener('resize', function() {
      // Get current data
      const currentData = d3.select("#sentimentLineChart").datum();
      if (currentData) {
        createSentimentLineChart(currentData);
        createStackedAreaChart(currentData);
        createTopicBubbleChart(d3.select("#topicBubbleChart").datum());
        createHeatmapChart(currentData);
      }
    });
  </script>
</body>
</html>
