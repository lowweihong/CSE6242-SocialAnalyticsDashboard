<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Topic Sentiment Heatmap</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <style>
    body {
      font-family: 'Tektur', monospace;
      margin: 0;
      padding: 20px;
      background-color: #2E3650;
      color: white;
    }
    
    #container {
      max-width: 1000px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #00F49E;
      margin-bottom: 30px;
      font-family: 'Tektur', monospace;
    }
    
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      margin-bottom: 20px;
      padding: 15px;
      background-color: #242B45;
      border-radius: 8px;
    }
    
    .filter-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .filter-label {
      margin-right: 10px;
      font-family: 'Tektur', monospace;
    }
    
    select {
      background-color: #1D253F;
      color: white;
      border: 1px solid #3D4B6D;
      padding: 6px 12px;
      border-radius: 4px;
      outline: none;
      font-family: 'Tektur', monospace;
    }
    
    select:focus {
      border-color: #00F49E;
    }
    
    #date-range {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
    }
    
    #date-range input {
      padding: 8px;
      background-color: #1D253F;
      border: 1px solid #3D4B6D;
      border-radius: 4px;
      color: white;
      font-family: 'Tektur', monospace;
      margin-right: 10px;
      margin-bottom: 5px;
    }
    
    #date-range button {
      padding: 8px 15px;
      background-color: #00F49E;
      border: none;
      border-radius: 4px;
      color: #1D253F;
      font-family: 'Tektur', monospace;
      cursor: pointer;
      font-weight: bold;
    }
    
    #date-range button:hover {
      background-color: #00D895;
    }
    
    #chart {
      background-color: #1D253F;
      border-radius: 8px;
      padding: 20px;
      position: relative;
      min-height: 400px;
    }
    
    #loading, #error {
      text-align: center;
      padding: 20px;
      font-size: 18px;
      font-family: 'Tektur', monospace;
    }
    
    #error {
      color: #E9538A;
      display: none;
    }
    
    .tooltip {
      position: absolute;
      padding: 10px;
      background-color: rgba(20, 20, 40, 0.9);
      border-radius: 5px;
      pointer-events: none;
      font-family: 'Tektur', monospace;
      font-size: 14px;
      max-width: 300px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .tooltip-header {
      font-weight: bold;
      margin-bottom: 5px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
      padding-bottom: 3px;
    }
    
    .tooltip-row {
      display: flex;
      justify-content: space-between;
      margin: 3px 0;
    }
    
    .tooltip-label {
      margin-right: 10px;
      font-weight: 600;
    }
    
    .axis text {
      fill: #CBD5E0;
      font-size: 12px;
      font-family: 'Tektur', monospace;
    }
    
    .axis line, .axis path {
      stroke: #4A5568;
    }
    
    .legend-item {
      cursor: pointer;
    }
    
    .legend-item:hover text {
      font-weight: bold;
    }
    
    .cell {
      transition: all 0.2s;
    }
    
    .time-option {
      padding: 8px 15px;
      margin: 5px;
      background-color: #1D253F;
      border: 1px solid #3D4B6D;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      font-family: 'Tektur', monospace;
      transition: all 0.2s ease;
    }
    
    .time-option:hover {
      background-color: #3D4B6D;
    }
    
    .time-option.active {
      background-color: #008FD6;
      border-color: #008FD6;
    }
    
    #topic-filter-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      margin: 10px 0;
    }
    
    #topic-selector {
      padding: 8px;
      background-color: #1D253F;
      border: 1px solid #3D4B6D;
      border-radius: 4px;
      color: white;
      font-family: 'Tektur', monospace;
      margin-top: 5px;
      max-width: 300px;
    }
    
    .status-bar {
      display: flex;
      align-items: center;
      margin-top: 10px;
      font-family: 'Tektur', monospace;
      font-size: 14px;
    }
    
    #status {
      margin-left: 10px;
      color: #00F49E;
    }
    
    #status.error {
      color: #E9538A;
    }
    
    .loading-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Topic Sentiment Heatmap</h1>
    
    <div id="controls">
      <div class="filter-group">
        <span class="filter-label">Filter by</span>
        <select id="sentiment-filter" title="Filter by sentiment">
          <option value="All">All</option>
          <option value="positive">Positive</option>
          <option value="neutral">Neutral</option>
          <option value="negative">Negative</option>
        </select>
      </div>
      
      <!-- Topic Filter -->
      <div id="topic-filter-container">
        <span class="filter-label">Select Topic</span>
        <select id="topic-selector" title="Filter by topic">
          <option value="All">All Topics</option>
          <!-- Will be populated from topic_detail_new.csv -->
        </select>
      </div>
      
      <div id="date-range">
        <span class="filter-label">From</span>
        <input type="date" id="start-date" title="Select the start date" placeholder="Start Date">
        <span class="filter-label">To</span>
        <input type="date" id="end-date" title="Select the end date" placeholder="End Date">
        <button id="apply-date-range">Apply</button>
      </div>
      
      <div class="filter-group">
        <button class="time-option active" data-period="all">All Time</button>
      </div>
      
      <div class="status-bar">
        <div id="loading-indicator" class="loading-indicator" style="display:none"></div>
        <div id="status"></div>
      </div>
    </div>
    
    <div id="error"></div>
    <div id="chart"></div>
  </div>
  
  <div id="tooltip" class="tooltip"></div>
  
  <script>
    // Use module pattern for better organization and performance
    const HeatmapVisualizer = (function() {
      // Private variables
      let topicDetails = [];
      let fullDataset = [];
      let currentTimeframe = 'all';
      let startDate = null;
      let endDate = null;
      let currentSentimentFilter = 'All';
      let currentTopicFilter = 'All';
      let processedData = [];
      let isDataLoaded = false;
      let isVisCreated = false;
      let worker = null;
      
      // Create web worker for data processing if supported
      function initWorker() {
        if (window.Worker) {
          const workerCode = `
            self.onmessage = function(e) {
              const { action, data } = e.data;
              
              if (action === 'processData') {
                const { dataset, timeframe, startDate, endDate, sentimentFilter, topicFilter, topicDetails } = data;
                const result = processHeatmapData(
                  filterData(dataset, timeframe, startDate, endDate, sentimentFilter, topicFilter),
                  topicDetails
                );
                self.postMessage({ action: 'processedData', data: result });
              }
              
              // Function to filter data
              function filterData(data, timeframe, customStartDate, customEndDate, sentimentFilter, topicFilter) {
                // Create a copy of the data to work with
                let filteredData = [...data];
                
                // Apply time filter based on selected option
                if (timeframe === 'custom' && customStartDate && customEndDate) {
                  // Filter by custom date range
                  filteredData = filteredData.filter(row => {
                    if (!row.timestamp) return false;
                    const rowDate = new Date(row.timestamp);
                    return !isNaN(rowDate) && rowDate >= new Date(customStartDate) && rowDate <= new Date(customEndDate);
                  });
                }
                
                // Apply sentiment filter if specified
                if (sentimentFilter && sentimentFilter !== 'All') {
                  filteredData = filteredData.filter(row => {
                    // Match sentiment_label (case-insensitive)
                    return row.sentiment_label && 
                          row.sentiment_label.toLowerCase() === sentimentFilter.toLowerCase();
                  });
                }
                
                // Apply topic filter if specified
                if (topicFilter && topicFilter !== 'All') {
                  filteredData = filteredData.filter(row => {
                    // Match either topic or new_topic
                    const rowTopic = row.topic !== undefined ? row.topic : row.new_topic;
                    return rowTopic == topicFilter; // Use == to handle string/number comparison
                  });
                }
                
                return filteredData;
              }
              
              // Process data for heatmap
              function processHeatmapData(data, topicDetails) {
                // Extract hours and dates from timestamps
                const sentimentByHourAndDate = {};
                
                data.forEach(row => {
                  if (!row.timestamp) return;
                  
                  const timestamp = new Date(row.timestamp);
                  if (isNaN(timestamp)) return;
                  
                  // Format hour and date
                  const hour = timestamp.getHours();
                  const hourFormatted = \`\${hour}:00\`;
                  
                  // Format as "MMM YYYY" for month-year
                  const date = new Date(timestamp);
                  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                  const monthYear = \`\${monthNames[date.getMonth()]} \${date.getFullYear()}\`;
                  
                  // Create key for grouping
                  const key = \`\${hourFormatted}-\${monthYear}\`;
                  
                  // Initialize if not exists
                  if (!sentimentByHourAndDate[key]) {
                    sentimentByHourAndDate[key] = {
                      hour: hourFormatted,
                      monthYear: monthYear,
                      sentiments: {
                        positive: 0,
                        neutral: 0,
                        negative: 0
                      },
                      total: 0,
                      // Store topic counts
                      topics: {}
                    };
                  }
                  
                  // Determine sentiment category
                  let sentimentCategory = 'neutral';
                  if (row.sentiment_label) {
                    const label = row.sentiment_label.toLowerCase();
                    if (label.includes('positive')) {
                      sentimentCategory = 'positive';
                    } else if (label.includes('negative')) {
                      sentimentCategory = 'negative';
                    }
                  }
                  
                  // Increment counter for this sentiment
                  sentimentByHourAndDate[key].sentiments[sentimentCategory]++;
                  sentimentByHourAndDate[key].total++;
                  
                  // Count topics
                  const topicId = row.topic !== undefined ? row.topic : (row.new_topic !== undefined ? row.new_topic : 'unknown');
                  if (topicId !== 'unknown') {
                    sentimentByHourAndDate[key].topics[topicId] = (sentimentByHourAndDate[key].topics[topicId] || 0) + 1;
                  }
                });
                
                // Convert to array and determine dominant sentiment
                const heatmapData = Object.values(sentimentByHourAndDate).map(item => {
                  const sentiments = item.sentiments;
                  let dominantSentiment = 'neutral';
                  let maxCount = 0;
                  
                  Object.entries(sentiments).forEach(([sentiment, count]) => {
                    if (count > maxCount) {
                      maxCount = count;
                      dominantSentiment = sentiment;
                    }
                  });
                  
                  // Find dominant topic
                  let dominantTopic = 'unknown';
                  let maxTopicCount = 0;
                  
                  Object.entries(item.topics).forEach(([topicId, count]) => {
                    if (count > maxTopicCount) {
                      maxTopicCount = count;
                      dominantTopic = topicId;
                    }
                  });
                  
                  // Get topic name if available
                  let topicName = \`Topic \${dominantTopic}\`;
                  const topicDetail = topicDetails.find(t => t.Topic == dominantTopic);
                  if (topicDetail && topicDetail.Name) {
                    topicName = topicDetail.Name;
                  }
                  
                  return {
                    hour: item.hour,
                    monthYear: item.monthYear,
                    sentiment: dominantSentiment,
                    counts: sentiments,
                    total: item.total,
                    topicCounts: item.topics,
                    dominantTopic: dominantTopic,
                    topicName: topicName
                  };
                });
                
                // Sort data for consistency
                return heatmapData.sort((a, b) => {
                  // Sort by month-year first
                  const [monthA, yearA] = a.monthYear.split(' ');
                  const [monthB, yearB] = b.monthYear.split(' ');
                  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                  
                  if (yearA !== yearB) return parseInt(yearA) - parseInt(yearB);
                  
                  const monthDiff = monthNames.indexOf(monthA) - monthNames.indexOf(monthB);
                  if (monthDiff !== 0) return monthDiff;
                  
                  // Then by hour
                  return parseInt(a.hour.split(':')[0]) - parseInt(b.hour.split(':')[0]);
                });
              }
            };
          `;
          
          // Create a blob and worker from the code
          const blob = new Blob([workerCode], {type: 'application/javascript'});
          worker = new Worker(URL.createObjectURL(blob));
          
          // Set up message handler
          worker.onmessage = function(e) {
            const { action, data } = e.data;
            
            if (action === 'processedData') {
              processedData = data;
              updateVisualization();
              document.getElementById('loading-indicator').style.display = 'none';
              document.getElementById('status').textContent = `Showing data for ${data.length} time periods`;
              setTimeout(() => {
                document.getElementById('status').textContent = '';
              }, 3000);
            }
          };
        }
      }
      
      // Process data with worker if available, otherwise process directly
      function processData() {
        document.getElementById('loading-indicator').style.display = 'inline-block';
        document.getElementById('status').textContent = 'Processing data...';
        
        if (worker) {
          worker.postMessage({
            action: 'processData',
            data: {
              dataset: fullDataset,
              timeframe: currentTimeframe,
              startDate: startDate ? startDate.toISOString() : null,
              endDate: endDate ? endDate.toISOString() : null,
              sentimentFilter: currentSentimentFilter,
              topicFilter: currentTopicFilter,
              topicDetails: topicDetails
            }
          });
        } else {
          // Fallback to synchronous processing
          setTimeout(() => {
            // Filter data based on current filters
            const filteredData = filterData(
              fullDataset,
              currentTimeframe,
              startDate,
              endDate,
              currentSentimentFilter,
              currentTopicFilter
            );
            
            // Process data for heatmap
            processedData = processHeatmapData(filteredData);
            
            // Update visualization
            updateVisualization();
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('status').textContent = `Showing data for ${processedData.length} time periods`;
            setTimeout(() => {
              document.getElementById('status').textContent = '';
            }, 3000);
          }, 10);
        }
      }
      
      // Synchronous filter function (fallback if Web Workers not available)
      function filterData(data, timeframe, customStartDate, customEndDate, sentimentFilter, topicFilter) {
        // Create a copy of the data to work with
        let filteredData = [...data];
        
        // Apply time filter based on selected option
        if (timeframe === 'custom' && customStartDate && customEndDate) {
          // Filter by custom date range
          filteredData = filteredData.filter(row => {
            if (!row.timestamp) return false;
            const rowDate = new Date(row.timestamp);
            return !isNaN(rowDate) && rowDate >= customStartDate && rowDate <= customEndDate;
          });
        }
        
        // Apply sentiment filter if specified
        if (sentimentFilter && sentimentFilter !== 'All') {
          filteredData = filteredData.filter(row => {
            // Match sentiment_label (case-insensitive)
            return row.sentiment_label && 
                  row.sentiment_label.toLowerCase() === sentimentFilter.toLowerCase();
          });
        }
        
        // Apply topic filter if specified
        if (topicFilter && topicFilter !== 'All') {
          filteredData = filteredData.filter(row => {
            // Match either topic or new_topic
            const rowTopic = row.topic !== undefined ? row.topic : row.new_topic;
            return rowTopic == topicFilter; // Use == to handle string/number comparison
          });
        }
        
        return filteredData;
      }
      
      // Synchronous heatmap processing (fallback if Web Workers not available)
      function processHeatmapData(data) {
        // Extract hours and dates from timestamps
        const sentimentByHourAndDate = {};
        
        data.forEach(row => {
          if (!row.timestamp) return;
          
          const timestamp = new Date(row.timestamp);
          if (isNaN(timestamp)) return;
          
          // Format hour and date
          const hour = timestamp.getHours();
          const hourFormatted = `${hour}:00`;
          
          // Format as "MMM YYYY" for month-year
          const date = new Date(timestamp);
          const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          const monthYear = `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
          
          // Create key for grouping
          const key = `${hourFormatted}-${monthYear}`;
          
          // Initialize if not exists
          if (!sentimentByHourAndDate[key]) {
            sentimentByHourAndDate[key] = {
              hour: hourFormatted,
              monthYear: monthYear,
              sentiments: {
                positive: 0,
                neutral: 0,
                negative: 0
              },
              total: 0,
              // Store topic counts
              topics: {}
            };
          }
          
          // Determine sentiment category
          let sentimentCategory = 'neutral';
          if (row.sentiment_label) {
            const label = row.sentiment_label.toLowerCase();
            if (label.includes('positive')) {
              sentimentCategory = 'positive';
            } else if (label.includes('negative')) {
              sentimentCategory = 'negative';
            }
          }
          
          // Increment counter for this sentiment
          sentimentByHourAndDate[key].sentiments[sentimentCategory]++;
          sentimentByHourAndDate[key].total++;
          
          // Count topics
          const topicId = row.topic !== undefined ? row.topic : (row.new_topic !== undefined ? row.new_topic : 'unknown');
          if (topicId !== 'unknown') {
            sentimentByHourAndDate[key].topics[topicId] = (sentimentByHourAndDate[key].topics[topicId] || 0) + 1;
          }
        });
        
        // Convert to array and determine dominant sentiment
        const heatmapData = Object.values(sentimentByHourAndDate).map(item => {
          const sentiments = item.sentiments;
          let dominantSentiment = 'neutral';
          let maxCount = 0;
          
          Object.entries(sentiments).forEach(([sentiment, count]) => {
            if (count > maxCount) {
              maxCount = count;
              dominantSentiment = sentiment;
            }
          });
          
          // Find dominant topic
          let dominantTopic = 'unknown';
          let maxTopicCount = 0;
          
          Object.entries(item.topics).forEach(([topicId, count]) => {
            if (count > maxTopicCount) {
              maxTopicCount = count;
              dominantTopic = topicId;
            }
          });
          
          // Get topic name if available
          let topicName = `Topic ${dominantTopic}`;
          const topicDetail = topicDetails.find(t => t.Topic == dominantTopic);
          if (topicDetail && topicDetail.Name) {
            topicName = topicDetail.Name;
          }
          
          return {
            hour: item.hour,
            monthYear: item.monthYear,
            sentiment: dominantSentiment,
            counts: sentiments,
            total: item.total,
            topicCounts: item.topics,
            dominantTopic: dominantTopic,
            topicName: topicName
          };
        });
        
        // Sort data for consistency
        return heatmapData.sort((a, b) => {
          // Sort by month-year first
          const [monthA, yearA] = a.monthYear.split(' ');
          const [monthB, yearB] = b.monthYear.split(' ');
          const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          
          if (yearA !== yearB) return parseInt(yearA) - parseInt(yearB);
          
          const monthDiff = monthNames.indexOf(monthA) - monthNames.indexOf(monthB);
          if (monthDiff !== 0) return monthDiff;
          
          // Then by hour
          return parseInt(a.hour.split(':')[0]) - parseInt(b.hour.split(':')[0]);
        });
      }
      
      // Load data with improved loading method (batched processing and caching)
      async function loadData() {
        try {
          document.getElementById('loading-indicator').style.display = 'inline-block';
          document.getElementById('status').textContent = 'Loading data...';
          
          // Check sessionStorage for cached data
          const cachedTopics = sessionStorage.getItem('topicDetails');
          const cachedCombined = sessionStorage.getItem('combinedData');
          
          if (cachedTopics && cachedCombined) {
            try {
              topicDetails = JSON.parse(cachedTopics);
              fullDataset = JSON.parse(cachedCombined);
              
              console.log("Loaded data from cache:", 
                topicDetails.length + " topics, " + 
                fullDataset.length + " combined records");
                
              populateTopicSelector(topicDetails);
              isDataLoaded = true;
              processData();
              return;
            } catch (e) {
              console.error("Error parsing cached data:", e);
              // Continue with fetch if cache parse fails
            }
          }
          
          // Load topic data with streaming approach for better performance
          const topicResponse = await fetch('topic_detail_new.csv');
          
          if (!topicResponse.ok) {
            throw new Error(`Failed to fetch topic data: ${topicResponse.status}`);
          }
          
          const topicText = await topicResponse.text();
          const parsedTopics = Papa.parse(topicText, {
            header: true,
            skipEmptyLines: true,
            dynamicTyping: true
          });
          
          topicDetails = parsedTopics.data;
          console.log("Loaded topic details:", topicDetails.length);
          
          // Populate topic selector dropdown
          populateTopicSelector(topicDetails);
          
          // Try to load combined data with fetch API
          try {
            const combinedResponse = await fetch('combined_df_new.csv');
            
            if (combinedResponse.ok) {
              // Use streaming for better performance with large files
              const combinedStream = combinedResponse.body;
              const combinedReader = combinedStream.getReader();
              const combinedDecoder = new TextDecoder();
              let combinedChunks = '';
              
              // Process in chunks
              let processedChunks = 0;
              
              while (true) {
                const { done, value } = await combinedReader.read();
                if (done) break;
                
                const chunk = combinedDecoder.decode(value, { stream: true });
                combinedChunks += chunk;
                processedChunks++;
                
                // Update status every 5 chunks
                if (processedChunks % 5 === 0) {
                  document.getElementById('status').textContent = `Loading combined data... (${(combinedChunks.length/1024/1024).toFixed(1)}MB)`;
                }
              }
              
              // Parse in a non-blocking way
              document.getElementById('status').textContent = 'Processing combined data...';
              
              setTimeout(() => {
                try {
                  const parsedCombined = Papa.parse(combinedChunks, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true
                  });
                  
                  fullDataset = parsedCombined.data;
                  console.log("Loaded combined data:", fullDataset.length);
                  
                  // Cache in sessionStorage for future use
                  try {
                    sessionStorage.setItem('topicDetails', JSON.stringify(topicDetails));
                    sessionStorage.setItem('combinedData', JSON.stringify(fullDataset));
                  } catch (e) {
                    console.warn("Couldn't cache data in sessionStorage:", e);
                  }
                  
                  isDataLoaded = true;
                  processData();
                } catch (e) {
                  console.error("Error parsing combined data:", e);
                  document.getElementById('status').textContent = 'Error processing data';
                  document.getElementById('status').className = 'error';
                  
                  // Still continue with topic data only
                  isDataLoaded = true;
                  processData();
                }
              }, 10);
            } else {
              // Fallback to out_40k.csv
              console.log("Failed to fetch combined_df_new.csv, trying out_40k.csv");
              document.getElementById('status').textContent = 'Trying alternate data source...';
              
              const fallbackResponse = await fetch('out_40k.csv');
              if (fallbackResponse.ok) {
                const fallbackText = await fallbackResponse.text();
                const parsedFallback = Papa.parse(fallbackText, {
                  header: true,
                  skipEmptyLines: true,
                  dynamicTyping: true
                });
                
                fullDataset = parsedFallback.data;
                console.log("Loaded out_40k.csv data:", fullDataset.length);
                
                // Store in sessionStorage
                try {
                  sessionStorage.setItem('topicDetails', JSON.stringify(topicDetails));
                  sessionStorage.setItem('combinedData', JSON.stringify(fullDataset));
                } catch (e) {
                  console.warn("Couldn't cache data in sessionStorage:", e);
                }
                
                isDataLoaded = true;
                processData();
              } else {
                console.warn("No combined data available");
                // Generate synthetic data
                fullDataset = generateSyntheticData();
                isDataLoaded = true;
                processData();
              }
            }
          } catch (error) {
            console.error("Error loading combined data:", error);
            document.getElementById('status').textContent = 'Error loading combined data';
            document.getElementById('status').className = 'error';
            
            // Generate synthetic data as fallback
            fullDataset = generateSyntheticData();
            isDataLoaded = true;
            processData();
          }
        } catch (error) {
          console.error("Error in loadData:", error);
          document.getElementById('status').textContent = 'Error: ' + error.message;
          document.getElementById('status').className = 'error';
          document.getElementById('loading-indicator').style.display = 'none';
        }
      }
      
      // Function to populate the topic selector with optimized loading
      function populateTopicSelector(topics) {
        const selector = document.getElementById('topic-selector');
        
        // Clear existing options except the first one
        while (selector.options.length > 1) {
          selector.remove(1);
        }
        
        // Sort topics by Count (descending) and then by Name
        const sortedTopics = [...topics]
          .sort((a, b) => {
            if (b.Count !== a.Count) return b.Count - a.Count;
            return (a.Name || '').localeCompare(b.Name || '');
          })
          .slice(0, 100); // Limit to top 100 topics for performance
        
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Add topic options
        sortedTopics.forEach(topic => {
          const option = document.createElement('option');
          option.value = topic.Topic;
          option.textContent = topic.Name ? `${topic.Name} (${topic.Count || 0})` : `Topic ${topic.Topic} (${topic.Count || 0})`;
          fragment.appendChild(option);
        });
        
        selector.appendChild(fragment);
      }
      
      // Create visualization with optimized rendering
      function updateVisualization() {
        if (!isDataLoaded || processedData.length === 0) {
          d3.select("#chart").html(
            '<div style="padding: 40px; text-align: center;">No data available with current filters</div>'
          );
          return;
        }
        
        // Clear any existing chart
        d3.select("#chart").selectAll("*").remove();
        
        // Extract unique hours and month-years - use Sets for better performance
        const uniqueHours = [...new Set(processedData.map(d => d.hour))]
          .sort((a, b) => parseInt(a.split(':')[0]) - parseInt(b.split(':')[0]));
        
        const uniqueMonthYears = [...new Set(processedData.map(d => d.monthYear))]
          .sort((a, b) => {
            const [monthA, yearA] = a.split(' ');
            const [monthB, yearB] = b.split(' ');
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            
            if (yearA !== yearB) return parseInt(yearA) - parseInt(yearB);
            return monthNames.indexOf(monthA) - monthNames.indexOf(monthB);
          });
        
        // Set up chart dimensions with responsive sizing
        const chartContainer = document.getElementById('chart');
        const containerWidth = chartContainer.clientWidth || 900;
        
        const margin = { top: 40, right: 30, bottom: 140, left: 60 };
        const width = Math.min(containerWidth - 60, Math.max(uniqueMonthYears.length * 40, 500)) - margin.left - margin.right;
        const height = Math.min(600, Math.max(uniqueHours.length * 30, 300)) - margin.top - margin.bottom;
        
        // Create SVG with viewBox for better responsiveness
        const svg = d3.select("#chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
          .attr("preserveAspectRatio", "xMidYMid meet")
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Create scales
        const x = d3.scaleBand()
          .domain(uniqueMonthYears)
          .range([0, width])
          .padding(0.05);
        
        const y = d3.scaleBand()
          .domain(uniqueHours)
          .range([0, height])
          .padding(0.05);
        
        // Add X axis - use clipPath to prevent overflow
        svg.append("defs")
          .append("clipPath")
          .attr("id", "clip-x-axis")
          .append("rect")
          .attr("width", width)
          .attr("height", margin.bottom);
        
        const xAxis = svg.append("g")
          .attr("class", "axis x-axis")
          .attr("transform", `translate(0,${height})`)
          .attr("clip-path", "url(#clip-x-axis)")
          .call(d3.axisBottom(x));
        
        // Rotate the X axis labels with performance optimization
        xAxis.selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-90)")
          .style("font-size", "11px");
        
        // Add Y axis
        svg.append("g")
          .attr("class", "axis y-axis")
          .call(d3.axisLeft(y));
        
        // Color scale for sentiments
        const colorScale = d3.scaleOrdinal()
          .domain(['positive', 'neutral', 'negative'])
          .range(['#008FD6', '#AF9FFF', '#FF70A5']); // Blue, Purple, Pink
        
        // Create a tooltip
        const tooltip = d3.select("#tooltip");
        
        // Create heatmap cells - use batch rendering for performance
        // Divide cells into batches to avoid blocking the UI
        const batchSize = 100;
        const batches = Math.ceil(processedData.length / batchSize);
        
        function renderBatch(batchIndex) {
          const start = batchIndex * batchSize;
          const end = Math.min(start + batchSize, processedData.length);
          const batchData = processedData.slice(start, end);
          
          svg.selectAll(`.cell-batch-${batchIndex}`)
            .data(batchData)
            .enter()
            .append("rect")
            .attr("class", `cell cell-batch-${batchIndex}`)
            .attr("x", d => x(d.monthYear))
            .attr("y", d => y(d.hour))
            .attr("width", x.bandwidth())
            .attr("height", y.bandwidth())
            .attr("fill", d => colorScale(d.sentiment))
            .attr("stroke", "#1D253F")
            .attr("stroke-width", 1)
            .on("mouseover", function(event, d) {
              // Highlight cell
              d3.select(this)
                .attr("stroke", "white")
                .attr("stroke-width", 2);
              
              // Prepare topic information for tooltip
              let topicInfo = '';
              if (Object.keys(d.topicCounts).length > 0) {
                // Get top 3 topics - optimize by pre-sorting
                const topTopics = Object.entries(d.topicCounts)
                  .sort((a, b) => b[1] - a[1])
                  .slice(0, 3);
                
                if (topTopics.length > 0) {
                  topicInfo = '<div class="tooltip-header">Top Topics:</div>';
                  
                  topTopics.forEach(([topicId, count]) => {
                    // Get topic name if available - using Map lookup for better performance
                    let topicName = `Topic ${topicId}`;
                    const topicDetail = topicDetails.find(t => t.Topic == topicId);
                    if (topicDetail && topicDetail.Name) {
                      topicName = topicDetail.Name;
                    }
                    
                    topicInfo += `
                      <div class="tooltip-row">
                        <span class="tooltip-label">${topicName}:</span>
                        <span>${count}</span>
                      </div>
                    `;
                  });
                }
              }
              
              // Create tooltip content
              let tooltipContent = `
                <div class="tooltip-header">${d.monthYear} at ${d.hour}</div>
                <div class="tooltip-row">
                  <span class="tooltip-label">Dominant:</span>
                  <span>${d.sentiment} (${d.counts[d.sentiment] || 0})</span>
                </div>
              `;
              
              // Add counts for each sentiment
              ['positive', 'neutral', 'negative'].forEach(sentiment => {
                if (d.counts[sentiment]) {
                  tooltipContent += `
                    <div class="tooltip-row">
                      <span class="tooltip-label">${sentiment}:</span>
                      <span>${d.counts[sentiment] || 0}</span>
                    </div>
                  `;
                }
              });
              
              // Add topic information if available
              if (topicInfo) {
                tooltipContent += topicInfo;
              }
              
              tooltip
                .html(tooltipContent)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px")
                .style("opacity", 1);
            })
            .on("mouseout", function() {
              // Restore cell appearance
              d3.select(this)
                .attr("stroke", "#1D253F")
                .attr("stroke-width", 1);
              
              // Hide tooltip
              tooltip.style("opacity", 0);
            });
          
          // Render next batch if available
          if (batchIndex < batches - 1) {
            setTimeout(() => renderBatch(batchIndex + 1), 0);
          }
        }
        
        // Start batch rendering
        if (batches > 0) {
          renderBatch(0);
        }
        
        // Add legend - use simplified rendering
        const legendData = [
          { label: "Positive", color: "#008FD6" },
          { label: "Neutral", color: "#AF9FFF" },
          { label: "Negative", color: "#FF70A5" }
        ];
        
        const legendWidth = 120 * legendData.length;
        const legendStartX = (width - legendWidth) / 2;
        
        const legend = svg.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${legendStartX}, ${height + 100})`);
        
        // Add all legend items at once for better performance
        legendData.forEach((d, i) => {
          const g = legend.append("g")
            .attr("class", "legend-item")
            .attr("transform", `translate(${i * 120}, 0)`)
            .on("click", function() {
              // Set sentiment filter and update
              currentSentimentFilter = d.label.toLowerCase();
              document.getElementById("sentiment-filter").value = currentSentimentFilter;
              processData();
            });
          
          g.append("rect")
            .attr("width", 18)
            .attr("height", 18)
            .attr("fill", d.color)
            .attr("rx", 3);
          
          g.append("text")
            .attr("x", 26)
            .attr("y", 14)
            .text(d.label)
            .attr("fill", "#fff");
        });
        
        // Add title with custom content based on filter
        let titleText = "Topic Sentiment by Hour and Month";
        
        // If a specific topic is filtered, include it in the title
        if (currentTopicFilter !== 'All') {
          const topicDetail = topicDetails.find(t => t.Topic == currentTopicFilter);
          if (topicDetail && topicDetail.Name) {
            titleText = `${topicDetail.Name} - Sentiment by Hour and Month`;
          }
        }
        
        svg.append("text")
          .attr("x", width / 2)
          .attr("y", -20)
          .attr("text-anchor", "middle")
          .attr("fill", "#00F49E")
          .style("font-size", "18px")
          .text(titleText);
          
        // Set flag that visualization is created
        isVisCreated = true;
      }
      
      // Synthetic data generator for testing
      function generateSyntheticData() {
        console.log("Generating synthetic data...");
        const data = [];
        
        // Generate some mock topics if we don't have real topic details
        const mockTopics = [];
        if (topicDetails.length === 0) {
          for (let i = 1; i <= 10; i++) {
            mockTopics.push({
              Topic: i,
              Name: `Topic ${i}`,
              Count: Math.floor(Math.random() * 1000) + 100
            });
          }
        }
        
        const useTopics = topicDetails.length > 0 ? topicDetails : mockTopics;
        
        // Define hours and dates
        const hours = Array.from({ length: 24 }, (_, i) => `${i}:00`);
        
        // Generate dates for the last 12 months - optimize by pre-calculating
        const dates = [];
        const today = new Date();
        const startDate = new Date(today);
        startDate.setFullYear(today.getFullYear() - 1);
        
        // Generate month-year combinations
        let currentDate = new Date(startDate);
        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        
        while (currentDate <= today) {
          const monthYear = `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
          
          if (!dates.includes(monthYear)) {
            dates.push(monthYear);
          }
          
          // Move to next month
          currentDate.setMonth(currentDate.getMonth() + 1);
        }
        
        // Optimize by batching data generation
        const batchSize = 1000;
        let generatedCount = 0;
        
        // Pre-compute some patterns for more realistic data
        const hourPatterns = {};
        for (let h = 0; h < 24; h++) {
          // Morning hours tend to be more negative, afternoon more positive
          if (h >= 9 && h <= 16) {
            // Business hours - more positive
            hourPatterns[`${h}:00`] = [0.6, 0.2, 0.2]; // [positive, neutral, negative]
          } else if (h >= 0 && h <= 5) {
            // Late night - more negative
            hourPatterns[`${h}:00`] = [0.3, 0.2, 0.5];
          } else {
            // Other hours - balanced
            hourPatterns[`${h}:00`] = [0.4, 0.3, 0.3];
          }
        }
        
        // Generate data in one pass for efficiency
        dates.forEach(monthYear => {
          hours.forEach(hour => {
            // Parse month-year to create a timestamp
            const [month, year] = monthYear.split(' ');
            const monthIndex = monthNames.indexOf(month);
            
            const timestamp = new Date(parseInt(year), monthIndex, 15, parseInt(hour), 0, 0);
            
            // Generate random number of tweets (10-50)
            const tweetCount = Math.floor(Math.random() * 40) + 10;
            
            // Choose pattern for this hour
            const pattern = hourPatterns[hour] || [0.33, 0.33, 0.34];
            
            // Generate tweets
            for (let i = 0; i < tweetCount; i++) {
              // Choose a random topic - optimize with pre-selection
              const randomTopic = useTopics[Math.floor(Math.random() * useTopics.length)];
              
              // Determine sentiment with pattern probabilities
              const rand = Math.random();
              let sentiment_label;
              
              if (rand < pattern[0]) {
                sentiment_label = "positive";
              } else if (rand < pattern[0] + pattern[1]) {
                sentiment_label = "neutral";
              } else {
                sentiment_label = "negative";
              }
              
              // Add some random variation to sentiment score
              const sentiment_score = sentiment_label === "positive" ? 
                                     0.7 + Math.random() * 0.3 : 
                                     (sentiment_label === "negative" ? 
                                      Math.random() * 0.3 : 
                                      0.3 + Math.random() * 0.4);
              
              // Create tweet record
              data.push({
                id: generatedCount++,
                user: `user_${Math.floor(Math.random() * 1000)}`,
                fullname: `User ${Math.floor(Math.random() * 1000)}`,
                timestamp: timestamp.toISOString(),
                text: `Sample tweet ${i} for ${monthYear} at ${hour}`,
                topic: randomTopic.Topic,
                new_topic: randomTopic.Topic,
                sentiment_label,
                sentiment_score
              });
              
              // Limit size for better performance
              if (generatedCount >= 10000) {
                console.log("Reached maximum synthetic data limit");
                return data;
              }
            }
          });
        });
        
        console.log(`Generated ${data.length} synthetic data points`);
        return data;
      }
      
      // Set up event listeners with debouncing for performance
      function setupEventListeners() {
        // Set initial dates
        const today = new Date();
        const oneMonthAgo = new Date();
        oneMonthAgo.setMonth(today.getMonth() - 1);
        
        document.getElementById('start-date').valueAsDate = oneMonthAgo;
        document.getElementById('end-date').valueAsDate = today;
        
        // Add event listener for sentiment filter with debounce
        let sentimentTimeout;
        document.getElementById("sentiment-filter").addEventListener("change", function() {
          clearTimeout(sentimentTimeout);
          document.getElementById('loading-indicator').style.display = 'inline-block';
          
          sentimentTimeout = setTimeout(() => {
            currentSentimentFilter = this.value;
            processData();
          }, 100);
        });
        
        // Add event listener for topic filter with debounce
        let topicTimeout;
        document.getElementById("topic-selector").addEventListener("change", function() {
          clearTimeout(topicTimeout);
          document.getElementById('loading-indicator').style.display = 'inline-block';
          
          topicTimeout = setTimeout(() => {
            currentTopicFilter = this.value;
            processData();
          }, 100);
        });
        
        // Add event listener for All Time button
        document.querySelector('.time-option[data-period="all"]').addEventListener('click', function() {
          currentTimeframe = 'all';
          startDate = null;
          endDate = null;
          
          // Update active state
          document.querySelectorAll('.time-option').forEach(btn => btn.classList.remove('active'));
          this.classList.add('active');
          
          processData();
        });
        
        // Add event listener for custom date range
        document.getElementById('apply-date-range').addEventListener('click', function() {
          const startDateInput = document.getElementById('start-date').value;
          const endDateInput = document.getElementById('end-date').value;
          
          if (startDateInput && endDateInput) {
            // Remove active class from time options
            document.querySelectorAll('.time-option').forEach(btn => btn.classList.remove('active'));
            
            // Set custom timeframe
            currentTimeframe = 'custom';
            startDate = new Date(startDateInput);
            endDate = new Date(endDateInput);
            endDate.setHours(23, 59, 59); // Set to end of day
            
            processData();
          } else {
            alert('Please select both start and end dates');
          }
        });
        
        // Handle window resize for responsive behavior
        let resizeTimeout;
        window.addEventListener('resize', function() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            if (isVisCreated && processedData.length > 0) {
              updateVisualization();
            }
          }, 250); // Debounce resize events
        });
      }
      
      // Initialize everything
      function init() {
        // Initialize web worker if supported
        initWorker();
        
        // Set up event listeners
        setupEventListeners();
        
        // Load data
        loadData();
      }
      
      // Return public API
      return {
        init: init
      };
    })();
    
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', HeatmapVisualizer.init);
  </script>
</body>
</html>